<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SUPERFLUID ETHER MODEL v4.0.2 | Natural Field</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000105; font-family: monospace; }
        .hud { position: absolute; padding: 25px; pointer-events: none; z-index: 100; width: 100%; color: #0ff; }
        .title { font-size: 18px; letter-spacing: 3px; text-shadow: 0 0 10px #0ff; }
        .controls { position: absolute; bottom: 30px; width: 100%; display: flex; justify-content: center; gap: 15px; z-index: 100; pointer-events: auto; }
        button { 
            padding: 12px 30px; font-size: 14px; font-weight: bold; border: 1px solid #0ff; border-radius: 4px; 
            cursor: pointer; transition: 0.3s; background: rgba(0, 255, 255, 0.1); color: #0ff;
        }
        button:hover { background: rgba(0, 255, 255, 0.3); box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); }
        #stopBtn { border-color: #f0f; color: #f0f; background: rgba(255, 0, 255, 0.1); }
    </style>
</head>
<body>
    <div class="hud">
        <div class="title">超流体モデル <small>SUPERFLUID MODEL v4.0.2</small></div>
        <div id="statText" style="color:#ffff00; font-size:12px; margin-top:5px;">FIELD: STABLE</div>
    </div>
    <div class="controls">
        <button id="igniteBtn">中心点火 (IGNITE)</button>
        <button id="stopBtn">真空崩壊 (DECAY)</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let units = [];
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        camera.position.set(18, 18, 18);
        camera.lookAt(0, 0, 0);

        function createUnit(x, y, z) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            
            [span_9](start_span)// 本体：視認性の高い発光ワイヤーフレーム[span_9](end_span)
            const geom = new THREE.TetrahedronGeometry(1.6);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff, wireframe: true, emissive: 0x00ffff, emissiveIntensity: 0.4
            });
            const mesh = new THREE.Mesh(geom, mat);
            group.add(mesh);

            [span_10](start_span)// 磁極：S/Nの極性を強調[span_10](end_span)
            const poles = [[1,1,1], [-1,-1,1], [-1,1,-1], [1,-1,-1]];
            const dots = [];
            poles.forEach((p, i) => {
                const color = i < 2 ? 0xff3333 : 0x3366ff;
                const dot = new THREE.Mesh(
                    new THREE.SphereGeometry(0.38, 12, 12),
                    new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 2 })
                );
                dot.position.set(p[0], p[1], p[2]);
                group.add(dot);
                dots.push(dot);
            });

            // v: 角速度ベクトル, isLocked: 崩壊フラグ
            const unit = { group, mesh, dots, v: new THREE.Vector3(0, 0, 0), isLocked: false };
            scene.add(group);
            return unit;
        }

        [span_11](start_span)// 3x3x3の高密度エーテル格子[span_11](end_span)
        for(let x=-1; x<=1; x++) {
            for(let y=-1; y<=1; y++) {
                for(let z=-1; z<=1; z++) {
                    const u = createUnit(x*4.8, y*4.8, z*4.8);
                    [span_12](start_span)// 7.356°の初期的な「ねじれ」を付与[span_12](end_span)
                    u.group.rotation.set(Math.random()*0.1, Math.random()*0.1, Math.random()*0.1);
                    units.push(u);
                }
            }
        }

        document.getElementById('igniteBtn').onclick = () => {
            units.forEach(u => {
                if(u.group.position.length() < 1) {
                    u.isLocked = false;
                    [span_13](start_span)u.v.set(Math.random()*10, 25, Math.random()*10); // 初動の爆発的回転[span_13](end_span)
                    document.getElementById('statText').innerText = "PHASE: SUPERFLUID VORTEX";
                }
            });
        };

        document.getElementById('stopBtn').onclick = () => {
            units.forEach(u => {
                if(u.group.position.length() < 1) {
                    [span_14](start_span)u.v.set(0, 0, 0); u.isLocked = true; // 真空崩壊の起点[span_14](end_span)
                    document.getElementById('statText').innerText = "PHASE: VACUUM DECAY";
                }
            });
        };

        function animate() {
            requestAnimationFrame(animate);
            
            [span_15](start_span)// 自然な磁気フィールド演算（ベクトルの向きによるトルク伝達）[span_15](end_span)
            for(let i=0; i<units.length; i++) {
                for(let j=i+1; j<units.length; j++) {
                    const u1 = units[i]; const u2 = units[j];
                    const distVec = u1.group.position.clone().sub(u2.group.position);
                    const d = distVec.length();
                    
                    if(d < 7.0) {
                        [span_16](start_span)// 1. 簡易的な指向性トルク：向きが似ているほど同期し、逆だと反発する[span_16](end_span)
                        const quatDiff = u1.group.quaternion.dot(u2.group.quaternion);
                        const fieldEffect = (1.0 - Math.abs(quatDiff)) * 0.05;
                        
                        const syncForce = u1.v.clone().sub(u2.v).multiplyScalar(0.04);
                        if(!u2.isLocked) u2.v.add(syncForce).addScalar(fieldEffect * 0.1);
                        if(!u1.isLocked) u1.v.sub(syncForce).subScalar(fieldEffect * 0.1);

                        [span_17](start_span)// 2. 非接触斥力：ギアのような接触を避けるクッション力[span_17](end_span)
                        const push = distVec.normalize().multiplyScalar(0.005 / (d*d));
                        if(!u1.isLocked) u1.group.position.add(push);
                        if(!u2.isLocked) u2.group.position.sub(push);
                    }
                }
            }

            units.forEach(u => {
                if(!u.isLocked) {
                    u.group.rotation.x += u.v.x * 0.04;
                    u.group.rotation.y += u.v.y * 0.04;
                    u.group.rotation.z += u.v.z * 0.04;
                    [span_18](start_span)u.v.multiplyScalar(0.9994); // 超流動の低摩擦[span_18](end_span)
                }
                const intensity = Math.min(u.v.length() * 0.1, 1.5);
                u.mesh.material.emissiveIntensity = 0.2 + intensity;
                u.dots.forEach(dot => dot.material.emissiveIntensity = 1 + intensity);
            });

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
