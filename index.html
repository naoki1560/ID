<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ID-GRID iPad v1.1</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; }
        #info { position: absolute; top: 10px; left: 10px; color: #0ff; font-family: monospace; pointer-events: none; }
    </style>
</head>
<body>
    <div id="info">ID-GRID: READY (TAP TO IGNITE)</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>

    <script>
        // 設定
        const GRID_SIZE = 3; // iPadの負荷を考慮して3x3x3
        const SPACING = 5;
        const units = [];

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        camera.position.set(12, 12, 12);
        camera.lookAt(0, 0, 0);

        // 正四面体ユニット
        class TetraUnit {
            constructor(pos) {
                this.group = new THREE.Group();
                this.group.position.copy(pos);
                
                const geom = new THREE.TetrahedronGeometry(1.2);
                const mat = new THREE.MeshBasicMaterial({ color: 0x444444, wireframe: true });
                this.mesh = new THREE.Mesh(geom, mat);
                this.group.add(this.mesh);

                // 磁極 (2N:赤, 2S:青)
                const pPos = [ [1,1,1], [-1,-1,1], [-1,1,-1], [1,-1,-1] ];
                pPos.forEach((p, i) => {
                    const dot = new THREE.Mesh(
                        new THREE.SphereGeometry(0.3),
                        new THREE.MeshBasicMaterial({ color: i < 2 ? 0xff0000 : 0x0000ff })
                    );
                    dot.position.set(p[0], p[1], p[2]);
                    this.group.add(dot);
                });

                this.v = new THREE.Vector3(0, 0, 0);
                scene.add(this.group);
            }
            update() {
                this.group.rotation.x += this.v.x;
                this.group.rotation.y += this.v.y;
                this.group.rotation.z += this.v.z;
                this.v.multiplyScalar(0.98); // 摩擦
            }
        }

        // グリッド作成
        for(let x=0; x<GRID_SIZE; x++) {
            for(let y=0; y<GRID_SIZE; y++) {
                for(let z=0; z<GRID_SIZE; z++) {
                    units.push(new TetraUnit(new THREE.Vector3(
                        (x-1)*SPACING, (y-1)*SPACING, (z-1)*SPACING
                    )));
                }
            }
        }

        // 磁気干渉（点火の伝播）
        function step() {
            for(let i=0; i<units.length; i++) {
                for(let j=i+1; j<units.length; j++) {
                    const d = units[i].group.position.distanceTo(units[j].group.position);
                    if(d < SPACING * 1.2) {
                        // 磁気トルク伝達（隣の回転を引きずり込む）
                        const force = units[i].v.clone().sub(units[j].v).multiplyScalar(0.02);
                        units[j].v.add(force);
                        units[i].v.sub(force);
                    }
                }
            }
        }

        // iPad用タッチイベント
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function handleTouch(e) {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(scene.children, true);
            if(hits.length > 0) {
                let target = hits[0].object;
                while(target.parent && !target.v) target = target.parent;
                if(target.v) target.v.set(Math.random()*2, 5, Math.random()*2); // 点火！
            }
        }
        window.addEventListener('touchstart', handleTouch);
        window.addEventListener('mousedown', handleTouch);

        function animate() {
            requestAnimationFrame(animate);
            step();
            units.forEach(u => u.update());
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
