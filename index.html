<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ID-GRID VACUUM DECAY</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: monospace; }
        .controls { position: absolute; bottom: 20px; width: 100%; display: flex; justify-content: center; gap: 10px; z-index: 100; }
        button { padding: 15px 25px; font-size: 18px; font-weight: bold; border: none; border-radius: 8px; cursor: pointer; }
        #igniteBtn { background: #00f; color: #fff; box-shadow: 0 0 15px #00f; }
        #stopBtn { background: #444; color: #fff; box-shadow: 0 0 15px #f00; }
        #info { position: absolute; top: 10px; left: 10px; color: #0ff; pointer-events: none; }
    </style>
</head>
<body>
    <div id="info">ID-GRID: DYNAMIC MODE<br>STATUS: <span id="statText">STANDBY</span></div>
    
    <div class="controls">
        <button id="igniteBtn">中心点火 (IGNITE)</button>
        <button id="stopBtn">中心のみ停止 (DECAY)</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let units = [];
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        camera.position.set(12, 12, 12);
        camera.lookAt(0, 0, 0);

        function createUnit(x, y, z) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            const geom = new THREE.TetrahedronGeometry(1.2);
            // 状態によって色を変えるためのマテリアル
            const mat = new THREE.MeshBasicMaterial({ color: 0x444444, wireframe: true });
            const mesh = new THREE.Mesh(geom, mat);
            group.add(mesh);

            const poles = [[1,1,1], [-1,-1,1], [-1,1,-1], [1,-1,-1]];
            const dots = [];
            poles.forEach((p, i) => {
                const dot = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3),
                    new THREE.MeshBasicMaterial({ color: i < 2 ? 0xff0000 : 0x0000ff })
                );
                dot.position.set(p[0], p[1], p[2]);
                group.add(dot);
                dots.push(dot);
            });

            const unit = { group, mesh, dots, v: new THREE.Vector3(0, 0, 0), isLocked: false };
            scene.add(group);
            return unit;
        }

        // 3x3x3グリッド
        for(let x=-1; x<=1; x++) {
            for(let y=-1; y<=1; y++) {
                for(let z=-1; z<=1; z++) {
                    units.push(createUnit(x*5, y*5, z*5));
                }
            }
        }

        // 点火ボタン：中心を活性化
        document.getElementById('igniteBtn').addEventListener('click', () => {
            units.forEach(u => {
                if(u.group.position.length() < 1) {
                    u.isLocked = false;
                    u.v.set(5, 15, 5); // 強烈なスピン
                    document.getElementById('statText').innerText = "VITALIZED";
                    document.getElementById('statText').style.color = "#0f0";
                }
            });
        });

        // 真空崩壊ボタン：中心のみを強制ロック
        document.getElementById('stopBtn').addEventListener('click', () => {
            units.forEach(u => {
                if(u.group.position.length() < 1) {
                    u.v.set(0, 0, 0);
                    u.isLocked = true; // ここが「死」のアンカーになる
                    document.getElementById('statText').innerText = "DECAY START";
                    document.getElementById('statText').style.color = "#f00";
                }
            });
        });

        function animate() {
            requestAnimationFrame(animate);
            
            // 相互干渉
            for(let i=0; i<units.length; i++) {
                for(let j=i+1; j<units.length; j++) {
                    const u1 = units[i];
                    const u2 = units[j];
                    const d = u1.group.position.distanceTo(u2.group.position);
                    if(d < 6) {
                        // トルク伝達（一方が止まっていると、もう一方も強力にブレーキがかかる）
                        const torque = u1.v.clone().sub(u2.v).multiplyScalar(0.03);
                        if(!u2.isLocked) u2.v.add(torque);
                        if(!u1.isLocked) u1.v.sub(torque);
                    }
                }
            }

            units.forEach(u => {
                if(!u.isLocked) {
                    u.group.rotation.x += u.v.x * 0.1;
                    u.group.rotation.y += u.v.y * 0.1;
                    u.group.rotation.z += u.v.z * 0.1;
                    u.v.multiplyScalar(0.999); // ほぼ摩擦なし
                }

                // 回転速度に合わせて色を変化（止まると暗くなる）
                const speed = u.v.length();
                const intensity = Math.min(speed * 0.1, 1);
                u.mesh.material.color.setRGB(intensity * 0.4, intensity * 0.8, intensity * 0.8);
                u.dots.forEach(dot => {
                    dot.material.opacity = 0.3 + intensity * 0.7;
                    dot.material.transparent = true;
                });
            });

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
